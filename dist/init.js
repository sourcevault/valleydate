// Generated by LiveScript 1.6.0
(function(){
  var reg, com, pkg, loopError, print, internal, cache, z, l, R, j, hop, deepFreeze, uic, custom, define, be, props, nonmap, base, not_base, undefnull, F, pop, i$, len$, ref$, name, type, A, B, notArrayofStrOrNum, reqError, resError, reqresError, objarr, restricted, integer, boolnum, maybe_boolnum, maybe, list, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  reg = require("./registry");
  com = reg.com, pkg = reg.pkg, loopError = reg.loopError, print = reg.print;
  internal = reg.internal, cache = reg.cache;
  z = com.z, l = com.l, R = com.R, j = com.j, hop = com.hop, deepFreeze = com.deepFreeze, uic = com.uic;
  custom = internal.custom, define = internal.define;
  be = custom;
  props = [['obj', 'Object'], ['arr', 'Array'], ['undef', 'Undefined'], ['null', 'Null'], ['num', 'Number'], ['str', 'String'], ['fun', 'Function'], ['bool', 'Boolean']];
  nonmap = R.map(function(arg$){
    var name;
    name = arg$[0];
    return name;
  }, R.drop(2, props));
  base = function(type){
    return function(UFO){
      var str;
      if (R.type(UFO) === type) {
        return {
          'continue': true,
          error: false,
          value: UFO
        };
      } else {
        str = R.toLower("not " + type);
        return {
          error: true,
          'continue': false,
          message: str,
          value: UFO
        };
      }
    };
  };
  not_base = function(type){
    return function(UFO){
      var str;
      if (R.type(UFO) === type) {
        str = R.toLower("is " + type);
        return {
          error: true,
          'continue': false,
          message: str,
          value: UFO
        };
      } else {
        return {
          'continue': true,
          error: false,
          value: UFO
        };
      }
    };
  };
  undefnull = function(UFO){
    var ref$;
    if ((ref$ = R.type(UFO)) === 'Undefined' || ref$ === 'Null') {
      return {
        'continue': true,
        error: false,
        value: UFO
      };
    } else {
      return {
        'continue': false,
        error: true,
        message: "not undefined or null",
        value: UFO
      };
    }
  };
  cache.def.add(undefnull);
  be.undefnull = be(undefnull);
  F = base("Arguments");
  define.basis("arg", F);
  be.arg = F;
  pop = function(msg){
    msg.pop();
    return msg;
  };
  be.not = function(F){
    return be(function(x){
      return !F(x)['continue'];
    });
  };
  be.maybe = function(F){
    return be(F).or(be.undef).err(pop);
  };
  be.list = function(F){
    return be.arr.map(F);
  };
  be.not[uic] = print.inner;
  be.list[uic] = print.inner;
  be.maybe[uic] = print.inner;
  for (i$ = 0, len$ = props.length; i$ < len$; ++i$) {
    ref$ = props[i$], name = ref$[0], type = ref$[1];
    A = base(type);
    base(name, A);
    define.basis(name, A);
    be[name] = A;
    B = not_base(type);
    define.basis(name, B);
    be.not[name] = B;
  }
  for (i$ = 0, len$ = nonmap.length; i$ < len$; ++i$) {
    name = nonmap[i$];
    be.maybe[name] = be.maybe(be[name]);
  }
  be.maybe.obj = be.obj.or(be.undef);
  be.maybe.arr = be.arr.or(be.undef);
  notArrayofStrOrNum = function(type){
    return function(){
      var args, i$, len$, key, ref$;
      args = R.flatten(arrayFrom$(arguments));
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        key = args[i$];
        if (!((ref$ = R.type(key)) === 'String' || ref$ === 'Number')) {
          print.route(['resreq', [type]]);
          return true;
        }
      }
      return false;
    };
  };
  reqError = hop.wh(notArrayofStrOrNum('req'), loopError);
  resError = hop.wh(notArrayofStrOrNum('res'), loopError);
  reqresError = hop.wh(function(req, res){
    var i$, len$, I, ref$;
    if (!(R.type(req) === "Array" && R.type(res) === "Array")) {
      print.route(['resreq', ['resreq', 'prime']]);
      return true;
    }
    for (i$ = 0, len$ = req.length; i$ < len$; ++i$) {
      I = req[i$];
      if (!((ref$ = R.type(I)) === 'String' || ref$ === 'Number')) {
        print.route(['resreq', ['resreq', 'res']]);
        return true;
      }
    }
    for (i$ = 0, len$ = res.length; i$ < len$; ++i$) {
      I = res[i$];
      if (!((ref$ = R.type(I)) === 'String' || ref$ === 'Number')) {
        print.route(['resreq', ['resreq', 'req']]);
        return true;
      }
    }
  }, loopError);
  objarr = be.obj.alt(be.arr).err(['prime', "not object or array"]);
  be.required = reqError.def(function(){
    var props, ret;
    props = R.flatten(arrayFrom$(arguments));
    ret = objarr.on(props, be.not.undef.err(['req', props]));
    return ret;
  });
  restricted = function(props, po){
    return function(obj){
      var keys, i$, len$, I;
      keys = Object.keys(obj);
      for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
        I = keys[i$];
        if (!po[I]) {
          return [false, ['res', props], I];
        }
      }
      return true;
    };
  };
  be.restricted = resError.def(function(){
    var props, po, i$, len$, I;
    props = R.flatten(arrayFrom$(arguments));
    po = {};
    for (i$ = 0, len$ = props.length; i$ < len$; ++i$) {
      I = props[i$];
      po[I] = true;
    }
    return objarr.and(restricted(props, po));
  });
  be.reqres = reqresError.def(function(req, res){
    var po, i$, len$, I;
    po = {};
    for (i$ = 0, len$ = res.length; i$ < len$; ++i$) {
      I = res[i$];
      po[I] = true;
    }
    return objarr.on(req, be.not.undef.err(['req', req])).and(restricted(res, po));
  });
  integer = function(UFO){
    var residue;
    if (!(R.type(UFO) === 'Number')) {
      return {
        'continue': false,
        error: true,
        message: "not an integer ( or number )",
        value: UFO
      };
    }
    residue = Math.abs(UFO - Math.round(UFO));
    if (residue > 0) {
      return {
        'continue': false,
        error: true,
        message: "not an integer",
        value: UFO
      };
    } else {
      return {
        'continue': true,
        error: false,
        value: UFO
      };
    }
  };
  cache.def.add(integer);
  boolnum = function(UFO){
    var ref$;
    if ((ref$ = R.type(UFO)) === 'Boolean' || ref$ === 'Number') {
      return {
        'continue': true,
        error: false,
        value: UFO
      };
    } else {
      return {
        'continue': false,
        error: true,
        message: "not a number or boolean",
        value: UFO
      };
    }
  };
  cache.def.add(boolnum);
  maybe_boolnum = function(UFO){
    var ref$;
    if ((ref$ = R.type(UFO)) === 'Undefined' || ref$ === 'Boolean' || ref$ === 'Number') {
      return {
        'continue': true,
        error: false,
        value: UFO
      };
    } else {
      return {
        'continue': false,
        error: true,
        message: "not a number or boolean",
        value: UFO
      };
    }
  };
  cache.def.add(maybe_boolnum);
  be.int = be(integer);
  be.boolnum = be(boolnum);
  be.int.neg = be.int.and(function(x){
    if (x <= 0) {
      return true;
    } else {
      return [false, "not a negative integer"];
    }
  });
  be.int.pos = be.int.and(function(x){
    if (x >= 0) {
      return true;
    } else {
      return [false, "not a positive integer"];
    }
  });
  maybe = be.maybe;
  maybe.int = be.int.or(be.undef);
  maybe.int.pos = maybe(be.int.pos);
  maybe.int.neg = maybe(be.int.neg);
  maybe.boolnum = be(maybe_boolnum);
  list = be.list;
  list.ofstr = list(be.str).err(function(msg, key){
    switch (R.type(key)) {
    case 'Undefined':
      return ['prime', "not a list of string."];
    default:
      return ['list', "not string type at ." + key[0]];
    }
  });
  list.ofnum = list(be.num).err(function(msg, key){
    switch (R.type(key)) {
    case 'Undefined':
      return ['prime', "not a list of number."];
    default:
      return ['list', "not number type at ." + key[0]];
    }
  });
  list.ofint = list(be.int).err(function(msg, key){
    switch (R.type(key)) {
    case 'Undefined':
      return ['prime', "not a list of integer."];
    default:
      return ['list', "not integer type at ." + key[0]];
    }
  });
  maybe.list = {};
  maybe.list.ofstr = maybe(list.ofstr);
  maybe.list.ofnum = maybe(list.ofnum);
  maybe.list.ofint = maybe(list.ofint);
  module.exports = be;
}).call(this);
