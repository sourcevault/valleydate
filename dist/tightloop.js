// Generated by LiveScript 1.6.0
(function(){
  var reg, com, already_created, pkgname, z, l, R, j, main, sanatize, red, settle, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  reg = require("./registry");
  com = reg.com, already_created = reg.already_created, pkgname = reg.pkgname;
  z = com.z, l = com.l, R = com.R, j = com.j;
  main = {};
  sanatize = function(F, x){
    var UFO, cont, unknown, msg;
    UFO = F(x);
    switch (R.type(UFO)) {
    case 'Boolean':
    case 'Null':
    case 'Undefined':
    case 'Number':
      if (UFO) {
        return {
          'continue': true,
          error: false,
          value: x
        };
      } else {
        return {
          'continue': false,
          error: true,
          value: x,
          message: ""
        };
      }
    case 'Array':
      cont = UFO[0], unknown = UFO[1];
      if (cont) {
        return {
          'continue': true,
          error: false,
          value: x
        };
      } else {
        switch (R.type(unknown)) {
        case 'String':
          msg = unknown;
          break;
        default:
          msg = "[" + pkgname + "][typeError][user-supplied-validator] message has to be string.";
        }
        return {
          'continue': false,
          error: true,
          value: x,
          message: msg
        };
      }
    default:
      return {
        'continue': false,
        error: true,
        value: x,
        message: "[" + pkgname + "][typeError][user-supplied-validator] undefined return value."
      };
    }
  };
  red = function(fun, put, extra){
    var patt, F, message;
    patt = fun[0], F = fun[1];
    switch (patt) {
    case 'err':
      message = (function(){
        switch (typeof F) {
        case 'function':
          return F(put.message, put.path, extra);
        default:
          return F;
        }
      }());
      put.message = message;
      return put;
    case 'fix':
      put.value = (function(){
        switch (typeof F) {
        case 'function':
          return F(value, path, extra);
        default:
          return F;
        }
      }());
      put['continue'] = true;
      put.error = false;
      return put;
    default:
      return put;
    }
  };
  settle = function(fun, put, type, extra){
    var patt, F, value, G, I, In, arr, path, ob, key, val, patt1, data, shape, ref$;
    patt = fun[0], F = fun[1];
    value = put.value;
    switch (patt) {
    case 's':
      return F(value);
    case 'f':
      return sanatize(F, value);
    case 'map':
      switch (type) {
      case 'arr':
        patt = F[0], G = F[1];
        I = 0;
        In = value.length;
        put = null;
        arr = [];
        while (I < In) {
          put = (fn$());
          if (put.path) {
            path = put.path;
          } else {
            path = [];
          }
          if (put.error) {
            return {
              'continue': false,
              error: true,
              value: value,
              message: put.message,
              path: [I].concat(arrayFrom$(path))
            };
          }
          arr.push(put.value);
          I += 1;
        }
        return {
          'continue': true,
          error: false,
          value: arr
        };
      case 'obj':
        ob = {};
        put = null;
        patt = F[0], G = F[1];
        for (key in value) {
          val = value[key];
          put = (fn1$());
          if (put.path) {
            path = put.path;
          } else {
            path = [];
          }
          if (put.error) {
            return {
              'continue': false,
              error: true,
              value: value,
              message: put.message,
              path: [key].concat(arrayFrom$(path))
            };
          }
          ob[key] = put.value;
        }
        return {
          'continue': true,
          error: false,
          value: ob
        };
      }
      break;
    case 'on':
      patt1 = F[0], data = F[1];
      switch (patt1) {
      case 'string':
        key = data[0], shape = data[1], G = data[2];
        put = (function(){
          switch (shape) {
          case 's':
            return G(value[key]);
          case 'f':
            return sanatize(G, value[key]);
          }
        }());
        if (put.path) {
          path = put.path;
        } else {
          path = [];
        }
        if (put.error) {
          return {
            'continue': false,
            error: true,
            value: value,
            message: put.message,
            path: [key].concat(arrayFrom$(path))
          };
        }
        if (!(put.value === undefined)) {
          value[key] = put.value;
        }
        return {
          'continue': true,
          error: false,
          value: value
        };
      case 'array':
        arr = data[0], shape = data[1], G = data[2];
        I = 0;
        In = arr.length;
        while (I < In) {
          key = arr[I];
          put = (fn2$());
          if (put.path) {
            path = put.path;
          } else {
            path = [];
          }
          if (put.error) {
            return {
              'continue': false,
              error: true,
              value: value,
              message: put.message,
              path: [key].concat(arrayFrom$(path))
            };
          }
          if (!(put.value === undefined)) {
            value[key] = put.value;
          }
          I += 1;
        }
        return {
          'continue': true,
          error: false,
          value: value
        };
      case 'object':
        I = 0;
        In = data.length;
        while (I < In) {
          ref$ = data[I], key = ref$[0], shape = ref$[1], G = ref$[2];
          put = (fn3$());
          if (put.path) {
            path = put.path;
          } else {
            path = [];
          }
          if (put.error) {
            return {
              'continue': false,
              error: true,
              value: value,
              message: put.message,
              path: [key].concat(arrayFrom$(path))
            };
          }
          if (!(put.value === undefined)) {
            value[key] = put.value;
          }
          I += 1;
        }
        return {
          'continue': true,
          error: false,
          value: value
        };
      }
      break;
    case 'cont':
      put.value = (function(){
        switch (typeof F) {
        case 'function':
          return F(value, extra);
        default:
          return F;
        }
      }());
      return put;
    case 'jam':
      put.message = (function(){
        switch (typeof F) {
        case 'function':
          return F(put.value, put.path, extra);
        default:
          return F;
        }
      }());
      put['continue'] = false;
      return put.error = true;
    default:
      return put;
    }
    function fn$(){
      switch (patt) {
      case 's':
        return G(value[I]);
      case 'f':
        return sanatize(G, value[I]);
      }
    }
    function fn1$(){
      switch (patt) {
      case 's':
        return G(value[key]);
      case 'f':
        return sanatize(G, value[key]);
      }
    }
    function fn2$(){
      switch (shape) {
      case 's':
        return G(value[key]);
      case 'f':
        return sanatize(G, value[key]);
      }
    }
    function fn3$(){
      switch (shape) {
      case 's':
        return G(value[key]);
      case 'f':
        return sanatize(G, value[key]);
      }
    }
  };
  reg.tightloop = function(state){
    return function(x, extra){
      var all, type, I, put, nI, each, J, nJ, fun, nput;
      all = state.all, type = state.type;
      I = 0;
      put = {
        'continue': true,
        error: false,
        value: x
      };
      nI = all.length;
      do {
        each = all[I];
        switch (I % 2) {
        case 0:
          J = 0;
          nJ = each.length;
          do {
            fun = each[J];
            if (put.error) {
              put = red(fun, put, extra);
            } else {
              put = settle(fun, put, type, extra);
            }
            J += 1;
          } while (J < nJ);
          if (put.error) {
            I += 1;
          } else {
            I += 2;
          }
          break;
        case 1:
          J = 0;
          nJ = each.length;
          do {
            nput = settle(each[J], put, type, extra);
            if (nput['continue']) {
              put = nput;
              break;
            }
            J += 1;
          } while (J < nJ);
          if (put['continue']) {
            I = nI;
          } else {
            I += 1;
          }
        }
      } while (I < nI);
      return put;
    };
  };
}).call(this);
