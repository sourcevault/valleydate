// Generated by LiveScript 1.6.0
(function(){
  var reg, com, print, pkgname, tightloop, already_created, z, l, R, hop, j, uic, initState, loopError, define, cato, custom, main_wrap, verify_on, main, props, boot, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
  reg = require("./registry");
  require("./print");
  require("./tightloop");
  com = reg.com, print = reg.print, pkgname = reg.pkgname, tightloop = reg.tightloop, already_created = reg.already_created;
  z = com.z, l = com.l, R = com.R, hop = com.hop, j = com.j, uic = com.uic;
  initState = {
    all: [],
    type: null,
    cont: null,
    err: null,
    phase: 'init',
    str: []
  };
  loopError = function(){
    var noop, apply, get;
    noop = function(){};
    apply = function(){
      return new Proxy(noop, {
        apply: apply,
        get: get
      });
    };
    get = function(){
      return new Proxy(noop, {
        apply: apply,
        get: get
      });
    };
    return new Proxy(noop, {
      apply: apply,
      get: get
    });
  };
  reg.loopError = loopError;
  define = {};
  cato = function(arg){
    var fun, i$, to$, I, F, block;
    switch (R.type(arg)) {
    case 'Function':
      switch (already_created.has(arg)) {
      case false:
        return ['f', arg];
      case true:
        return ['s', arg];
      }
      break;
    case 'Arguments':
      fun = [];
      for (i$ = 0, to$ = arg.length; i$ < to$; ++i$) {
        I = i$;
        F = arg[I];
        block = (fn$());
        fun.push(block);
      }
      return fun;
    }
    function fn$(){
      switch (already_created.has(F)) {
      case false:
        return ['f', F];
      case true:
        return ['s', F];
      }
    }
  };
  define.base = function(name){
    return function(UFO){
      var ut, str;
      ut = R.type(UFO);
      if (ut === name) {
        return {
          'continue': true,
          error: false,
          value: UFO
        };
      } else {
        str = R.toLower("not " + name);
        return {
          error: true,
          'continue': false,
          message: str,
          value: UFO
        };
      }
    };
  };
  define.notbase = function(name){
    return function(UFO){
      var ut, str;
      ut = R.type(UFO);
      if (ut === name) {
        str = R.toLower("is " + name);
        return {
          error: true,
          'continue': false,
          message: str,
          value: UFO
        };
      } else {
        return {
          'continue': true,
          error: false,
          value: UFO
        };
      }
    };
  };
  custom = hop.arn(1, function(){
    print.route(['input.fault', ['custom', ['arg_count']]]);
    return loopError();
  }).whn(function(f){
    return R.type(f) === 'Function';
  }, function(){
    print.route(['input.fault', ['custom', ['not_function']]]);
    return loopError();
  }).def(function(F){
    var neo;
    neo = Object.assign({}, initState, {
      type: 'custom',
      all: [[cato(F)]],
      phase: 'chain',
      str: [pkgname]
    });
    return define.forward('custom', neo);
  });
  main_wrap = function(type, state){
    return function(){
      return main(type, state, arguments);
    };
  };
  define.forward = function(type, neo, fun){
    var forward;
    if (fun) {
      forward = fun;
    } else {
      forward = tightloop(neo);
    }
    forward[uic] = print.log;
    forward.and = main_wrap('and', neo);
    forward.or = main_wrap('or', neo);
    forward.cont = main_wrap('cont', neo);
    forward.jam = main_wrap('jam', neo);
    forward.fix = main_wrap('fix', neo);
    forward.err = main_wrap('err', neo);
    if (type === 'obj' || type === 'arr') {
      forward.map = main_wrap('map', neo);
      forward.on = main_wrap('on', neo);
    }
    already_created.add(forward);
    return forward;
  };
  define.and = function(state, funs){
    var all, last, init, nlast, block;
    all = state.all;
    switch (all.length % 2) {
    case 0:
      return all.concat([funs]);
    case 1:
      last = R.last(all);
      init = R.init(all);
      nlast = arrayFrom$(last).concat(arrayFrom$(funs));
      block = arrayFrom$(init).concat([nlast]);
      return block;
    }
  };
  define.or = function(state, funs){
    var all, last, init, nlast, block;
    all = state.all;
    switch (all.length % 2) {
    case 0:
      last = R.last(all);
      init = R.init(all);
      nlast = arrayFrom$(last).concat(arrayFrom$(funs));
      block = arrayFrom$(init).concat([nlast]);
      return block;
    case 1:
      return all.concat([funs]);
    }
  };
  verify_on = hop.unary.arn([1, 2], function(args, state){
    return ['input.fault', ['on', ['arg_count', [state.str, 'on']]]];
  }).arma(1, function(arg$, state){
    var maybeObject, I, val;
    maybeObject = arg$[0];
    if (R.type(maybeObject) === 'Object') {
      for (I in maybeObject) {
        val = maybeObject[I];
        if (!(R.type(val) === 'Function')) {
          return ['input.fault', ['on', ['object', [state.str, 'on']]]];
        }
      }
      return ['object'];
    } else {
      return false;
    }
  }).arma(2, function(arg$, state){
    var maybeArray, maybeFunction, i$, len$, I;
    maybeArray = arg$[0], maybeFunction = arg$[1];
    if (R.type(maybeArray) === 'Array') {
      for (i$ = 0, len$ = maybeArray.length; i$ < len$; ++i$) {
        I = maybeArray[i$];
        if (!(R.type(I) === 'String')) {
          return ['input.fault', ['on', ['array', [state.str, 'on']]]];
        }
      }
      if (!(R.type(maybeFunction) === 'Function')) {
        return ['input.fault', ['on', ['array', [state.str, 'on']]]];
      }
      return ['array'];
    } else {
      return false;
    }
  }, function(arg$, state){
    var maybeString, maybeFunction;
    maybeString = arg$[0], maybeFunction = arg$[1];
    if (!(R.type(maybeString) === 'String')) {
      return false;
    }
    if (!(R.type(maybeFunction) === 'Function')) {
      return ['input.fault', ['on', ['string', [state.str, 'on']]]];
    }
    return ['string'];
  }).def(function(args, state){
    return ['input.fault', ['on', ['typeError', [state.str, 'on']]]];
  });
  define.on = function(type, state, args){
    var props, F, put, key, ob, fun, res$, val, block, neo;
    switch (type) {
    case 'array':
      props = args[0], F = args[1];
      put = ['on', ['array', [R.uniq(props)].concat(arrayFrom$(cato(F)))]];
      break;
    case 'string':
      key = args[0], F = args[1];
      put = ['on', ['string', [key].concat(arrayFrom$(cato(F)))]];
      put;
      break;
    case 'object':
      ob = args[0];
      res$ = [];
      for (key in ob) {
        val = ob[key];
        res$.push([key].concat(arrayFrom$(cato(val))));
      }
      fun = res$;
      put = ['on', ['object', fun]];
    }
    block = define.and(state, [put]);
    neo = Object.assign({}, state, {
      phase: 'chain',
      all: block,
      str: state.str.concat('on')
    });
    return define.forward(state.type, neo);
  };
  main = hop.wh(function(type, state, args){
    return (type === 'cont' || type === 'jam') && state.phase === 'chain';
  }, function(type, state, arg$){
    var f, neo, forward;
    f = arg$[0];
    neo = Object.assign({}, state, {
      phase: 'end',
      cont: [type, f],
      str: state.str.concat(type)
    });
    forward = tightloop(neo);
    forward.fix = main_wrap('fix', neo);
    forward.err = main_wrap('err', neo);
    forward[uic] = print.log;
    already_created.add(forward);
    return forward;
  }).wh(function(type, state, args){
    return (type === 'err' || type === 'fix') && state.phase === 'chain';
  }, function(type, state, arg$){
    var f, neo, forward;
    f = arg$[0];
    neo = Object.assign({}, state, {
      phase: 'end',
      str: state.str.concat(type)
    });
    neo.err = [type, f];
    forward = tightloop(neo);
    forward.cont = main_wrap('cont', neo);
    forward.jam = main_wrap('jam', neo);
    forward[uic] = print.log;
    already_created.add(forward);
    return forward;
  }).wh(function(type, state, args){
    return state.phase === 'end';
  }, function(type, state, arg$){
    var f, neo, F;
    f = arg$[0];
    neo = Object.assign(state, {});
    switch (type) {
    case 'err':
    case 'fix':
      neo.err = [type, f];
      break;
    case 'cont':
    case 'jam':
      neo.cont = [type, f];
    }
    F = tightloop(neo);
    already_created.add(F);
    return F;
  }).wh(function(type){
    return type === 'on';
  }, function(type, state, args){
    var patt;
    patt = verify_on(args, state);
    type = patt[0];
    switch (type) {
    case 'input.fault':
      print.route(patt);
      return loopError();
    }
    return define.on(type, state, args);
  }).wh(function(type, state, funs){
    var i$, len$, F, f;
    switch (type) {
    case 'and':
    case 'or':
      if (funs.length === 0) {
        print.route(['input.fault', [type, ['arg_count', [state.str, type]]]]);
        return false;
      }
      for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
        F = funs[i$];
        if (!(R.type(F) === 'Function')) {
          print.route(['input.fault', [type, ['not_function', [state.str, type]]]]);
          false;
        }
      }
      return true;
    case 'map':
      if (!(funs.length === 1)) {
        print.route(['input.fault', [type, ['arg_count', [state.str, type]]]]);
        return false;
      }
      f = funs[0];
      if (!(R.type(f) === 'Function')) {
        print.route(['input.fault', [type, ['not_function', [state.str, type]]]]);
        return false;
      }
      return true;
    default:
      return false;
    }
  }, function(type, state, args){
    var funs, block, neo;
    funs = cato(args);
    block = (function(){
      switch (type) {
      case 'and':
        return define.and(state, funs);
      case 'or':
        return define.or(state, funs);
      case 'map':
        return define.and(state, [['map', funs[0]]]);
      }
    }());
    neo = Object.assign({}, state, {
      phase: 'chain',
      all: block,
      str: state.str.concat(type)
    });
    return define.forward(state.type, neo);
  }).def(loopError);
  props = [['obj', 'Object'], ['arr', 'Array'], ['undef', 'Undefined'], ['null', 'Null'], ['num', 'Number'], ['str', 'String'], ['fun', 'Function']];
  boot = function(){
    var i$, ref$, len$, ref1$, name, type, F, neo;
    for (i$ = 0, len$ = (ref$ = props).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], name = ref1$[0], type = ref1$[1];
      F = define.base(type);
      already_created.add(F);
      neo = Object.assign({}, initState, {
        type: name,
        all: [[['s', F]]],
        phase: 'chain',
        str: [name]
      });
      define.forward(name, neo, F);
      custom[name] = F;
    }
    custom.not = {};
    for (i$ = 0, len$ = (ref$ = props).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], name = ref1$[0], type = ref1$[1];
      F = define.notbase(type);
      already_created.add(F);
      neo = Object.assign({}, initState, {
        type: name,
        all: [[['s', F]]],
        phase: 'chain',
        str: [name]
      });
      define.forward(name, neo, F);
      custom.not[name] = F;
    }
    return custom;
  };
  reg.pkg = boot();
  require("./helper");
  module.exports = reg.pkg;
}).call(this);
