// Generated by LiveScript 1.6.0
(function(){
  var ref$, l, SI, R, guard, noops, moduleName, unfinished, sim, utilInspectCustom, registry, print, genproxSave, genproxSimple, incache, validator_get, validator_initial, validator_basetype, validator_call, ap_call, get, ap, handle, start;
  ref$ = require("./common"), l = ref$.l, SI = ref$.SI, R = ref$.R, guard = ref$.guard, noops = ref$.noops, moduleName = ref$.moduleName;
  ref$ = require("./common"), unfinished = ref$.unfinished, sim = ref$.sim, utilInspectCustom = ref$.utilInspectCustom;
  registry = require("./registry");
  require("./validators");
  print = require("./print");
  genproxSave = function(neo, old, key){
    var P, common, current_cache, store;
    P = new Proxy(noops, handle.of(neo));
    common = registry.cache.common;
    if (common.has(old)) {
      current_cache = common.get(old);
      current_cache[key] = P;
    } else {
      store = {};
      common.set(old, store);
      store[key] = P;
    }
    registry.cache.all.add(P);
    return P;
  };
  genproxSimple = function(neo, old){
    var P;
    P = new Proxy(noops, handle.of(neo));
    registry.cache.all.add(P);
    return P;
  };
  incache = function(data, key){
    var found;
    found = registry.cache.common.get(data);
    if (found) {
      return found[key];
    } else {
      return false;
    }
  };
  validator_get = function(data, key){
    var neo;
    neo = data.set("call", key);
    return genproxSimple(neo, data);
  };
  validator_initial = function(data, key){
    var baseF, neo;
    baseF = registry.basetype[key];
    neo = SI.merge(data, {
      validator: baseF,
      type: key
    });
    return genproxSave(neo, data, key);
  };
  validator_basetype = function(data, args){
    var type, validator, v, neo;
    type = args[0], validator = args[1];
    v = function(val){
      return registry.sanatize(validator, val);
    };
    neo = SI.merge(data, {
      validator: v,
      type: type
    });
    return genproxSimple(neo, data);
  };
  validator_call = function(data, args){
    var update, neo;
    update = {
      call: null,
      validator: registry.router[data.call](data, args),
      all: [[data.call, args]]
    };
    neo = data.merge(update, {
      merger: sim.concatArrayMerger
    });
    return genproxSimple(neo, data);
  };
  ap_call = function(data, arg$){
    var val, rets;
    val = arg$[0];
    rets = data.validator(val);
    registry.sideEffects(data, rets);
    return rets;
  };
  registry.router['continue'] = function(data, f){
    var update, neo;
    update = {
      call: null,
      all: [[data.call, f]]
    };
    update[data.call] = f;
    neo = data.merge(update, {
      merger: sim.concatArrayMerger
    });
    return genproxSimple(neo);
  };
  registry.router.error = registry.router['continue'];
  get = guard(function(data, key){
    return key === utilInspectCustom;
  }, print.pretty).when(incache, incache).when(function(d, k){
    return d.type && registry.router[k];
  }, validator_get).when(function(d, k){
    return registry.basetype[k];
  }, validator_initial).when(function(d, k){
    return registry.helper[k];
  }, unfinished("get.helper")).any(print.not_in_base_or_help);
  ap = guard(function(data, args){
    return registry.router[data.call];
  }, validator_call).when(function(data, args){
    return !data.validator && !data.type;
  }, validator_basetype).when(function(data){
    return data.validator && data.type;
  }, ap_call).any(print.noapi);
  handle = function(data){
    this.data = data;
    return this;
  };
  handle.prototype.get = function(__, key, ___){
    return get(this.data, key);
  };
  handle.prototype.apply = function(__, ___, args){
    return ap(this.data, args);
  };
  handle.of = function(data){
    return new handle(data);
  };
  start = function(){
    var defData, init, IS;
    defData = {
      all: [],
      validator: null,
      type: null,
      call: null,
      'continue': null,
      error: null
    };
    init = SI(defData);
    IS = new Proxy(noops, handle.of(init));
    registry.cache.common.set(init, {});
    registry.cache.all.add(IS);
    return IS;
  };
  module.exports = start();
}).call(this);
