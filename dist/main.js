// Generated by LiveScript 1.6.0
(function(){
  var ref$, l, SI, R, guard, guardjs, noops, moduleName, unfinished, sim, utilInspectCustom, registry, print, genproxSave, genproxSimple, incache, validator_get, validator_initial, validator_basetype, validator_call, ap_call, verifyGet, get, verify, ap, handle, start;
  ref$ = require("./common"), l = ref$.l, SI = ref$.SI, R = ref$.R, guard = ref$.guard, guardjs = ref$.guardjs, noops = ref$.noops, moduleName = ref$.moduleName;
  ref$ = require("./common"), unfinished = ref$.unfinished, sim = ref$.sim, utilInspectCustom = ref$.utilInspectCustom;
  registry = require("./registry");
  require("./validators");
  require("./helper");
  print = require("./print");
  genproxSave = function(neo, old, key){
    var P, common, current_cache, store;
    P = new Proxy(noops, handle.of(neo));
    common = registry.cache.common;
    if (common.has(old)) {
      current_cache = common.get(old);
      current_cache[key] = P;
    } else {
      store = {};
      common.set(old, store);
      store[key] = P;
    }
    registry.cache.all.add(P);
    return P;
  };
  genproxSimple = function(neo, old){
    var P;
    P = new Proxy(noops, handle.of(neo));
    registry.cache.all.add(P);
    return P;
  };
  incache = function(data, key){
    var found;
    found = registry.cache.common.get(data);
    if (found) {
      return found[key];
    } else {
      return false;
    }
  };
  validator_get = function(data, key){
    var neo;
    neo = data.set("call", key);
    return genproxSimple(neo, data);
  };
  validator_initial = function(data, key){
    var baseF, neo;
    baseF = registry.basetype[key];
    neo = SI.merge(data, {
      validator: baseF,
      type: key
    });
    return genproxSave(neo, data, key);
  };
  validator_basetype = function(data, args){
    var type, validator, v, neo;
    type = args[0], validator = args[1];
    v = function(val){
      return registry.sanatize(validator, val);
    };
    neo = SI.merge(data, {
      validator: v,
      type: type
    });
    return genproxSimple(neo, data);
  };
  validator_call = function(data, args){
    var update, neo;
    update = {
      call: null,
      validator: registry.router[data.call](data, args),
      all: [[data.call, args]]
    };
    neo = data.merge(update, {
      merger: sim.concatArrayMerger
    });
    return genproxSimple(neo, data);
  };
  ap_call = function(data, arg$){
    var val, rets;
    val = arg$[0];
    rets = data.validator(val);
    registry.sideEffects(data, rets);
    return rets;
  };
  registry.router['continue'] = function(data, f){
    var update, neo;
    update = {
      call: null,
      all: [[data.call, f]]
    };
    update[data.call] = f;
    neo = data.merge(update, {
      merger: sim.concatArrayMerger
    });
    return genproxSimple(neo);
  };
  registry.router.error = registry.router['continue'];
  verifyGet = guard(function(data, key){
    return key === 'map';
  }, guard(function(data){
    var ref$;
    return (ref$ = data.type) === 'array' || ref$ === 'object';
  }, validator_get).any(print.wrong_basetype_for_map)).when(function(data, key){
    return key === 'on';
  }, guard(function(data){
    return registry.unit.on[data.type];
  }, validator_get).any(print.wrong_basetype_for_on)).when(function(data, key){
    return registry.router[key];
  }, validator_get).any(print.not_unit);
  get = guard(function(data, key){
    return key === utilInspectCustom;
  }, print.pretty).when(incache, incache).when(function(d, k){
    return d.type;
  }, verifyGet).when(function(d, k){
    return registry.basetype[k];
  }, validator_initial).when(function(d, k){
    return registry.helper[k];
  }, function(d, k){
    return registry.helper[k];
  }).when(function(d, k){
    return registry.router[k];
  }, print.unit_not_on_top).any(print.not_in_base_or_help);
  verify = {};
  verify.ap = {};
  verify.ap.on_object = function(data, args){
    var ref$;
    switch (args.length) {
    case 1:
      return typeof args[0] === "object";
    case 2:
      if (!((ref$ = typeof args[0]) === "string" || ref$ === "number")) {
        return false;
      }
      switch (data.type) {
      case "number":
      case "string":
        return Array.isArray(args[1]);
      case "object":
      case "array":
        return typeof args[1] === "function";
      }
      break;
    default:
      return false;
    }
  };
  verify.ap.on_rest = function(data, args){
    return typeof args[0] === 'function';
  };
  verify.ap.main = guardjs().when(function(data, args){
    return data.call === 'on' && registry.unit.on[data.type];
  }, guardjs().when(verify.ap.on_object, validator_call).any(print.wrong_type_for_object_on)).when(verify.ap.on_rest, validator_call).any(print.call_has_to_be_function);
  ap = guard(function(data, args){
    return registry.router[data.call];
  }, verify.ap.main).when(function(data){
    return data.validator && data.type;
  }, ap_call).when(function(data, args){
    return !data.validator && !data.type && data.all.length === 0;
  }, print.top_level_is_not_function).any(print.unknown_ap_call);
  handle = function(data){
    this.data = data;
    return this;
  };
  handle.prototype.get = function(__, key, ___){
    return get(this.data, key);
  };
  handle.prototype.apply = function(__, ___, args){
    return ap(this.data, args);
  };
  handle.of = function(data){
    return new handle(data);
  };
  start = function(){
    var defData, init, IS;
    defData = {
      all: [],
      validator: null,
      type: null,
      call: null,
      'continue': null,
      error: null
    };
    init = SI(defData);
    IS = new Proxy(noops, handle.of(init));
    registry.cache.common.set(init, {});
    registry.cache.all.add(IS);
    registry.is = IS;
    return IS;
  };
  module.exports = start();
}).call(this);
