// Generated by LiveScript 1.6.0
(function(){
  var ref$, z, SI, R, guard, guardjs, noop, moduleName, unfinished, sim, utilInspectCustom, registry, print, emit, verify, get, ap, handle, start, IS;
  ref$ = require("./common"), z = ref$.z, SI = ref$.SI, R = ref$.R, guard = ref$.guard, guardjs = ref$.guardjs, noop = ref$.noop, moduleName = ref$.moduleName;
  ref$ = require("./common"), unfinished = ref$.unfinished, sim = ref$.sim, utilInspectCustom = ref$.utilInspectCustom;
  registry = require("./registry");
  require("./validators");
  require("./helper");
  print = require("./print");
  emit = registry.emit, verify = registry.verify;
  verify.ap.on.types = function(data, args){
    var ref$;
    switch (args.length) {
    case 1:
      return typeof args[0] === "object";
    case 2:
      if (!((ref$ = typeof args[0]) === 'string' || ref$ === 'number')) {
        return false;
      }
      if (!(typeof args[1] === 'function')) {
        return false;
      }
      return true;
    default:
      return false;
    }
  };
  emit.prox = function(data){
    var P;
    P = new Proxy(noop, handle.of(
    data));
    registry.cache.all.add(P);
    return P;
  };
  emit.get.chain = function(data, key){
    var neo;
    neo = data.set('call', key);
    return emit.prox(neo);
  };
  emit.get.basetype = function(data, key){
    var ref$, common, all, stored, baseF, neo, P;
    ref$ = registry.cache, common = ref$.common, all = ref$.all;
    stored = common[key];
    if (!stored) {
      baseF = registry.basetype[key];
      neo = SI.merge(data, {
        validator: baseF,
        type: key,
        state: 'chain'
      });
      P = new Proxy(noop, handle.of(neo));
      common[key] = P;
      all.add(P);
      return P;
    } else {
      return stored;
    }
  };
  emit.ap.chain = function(data, args){
    var Fns, update, neo;
    Fns = R.flatten(args);
    update = {
      call: null,
      validator: registry.router[data.call](data, Fns),
      all: [[data.call, args]]
    };
    neo = data.merge(update, {
      merger: sim.concatArrayMerger
    });
    return emit.prox(neo);
  };
  registry.fault.get = function(data, call){
    return emit.prox(
    data.merge(
    {
      fault: true,
      call: call
    }));
  };
  emit.end = function(data, key){
    var info;
    info = {
      call: key,
      state: 'end'
    };
    if (key === "error" || key === "fix") {
      info.lockE = true;
    }
    return emit.prox(
    data.merge(
    info));
  };
  emit.ap.resolve = function(data, arg$){
    var val, ret;
    val = arg$[0];
    ret = data.validator(val);
    return registry.sideEffects(data, ret);
  };
  emit.ap.end = function(data, f){
    var update, neo;
    update = {
      call: null,
      all: [[data.call, f]]
    };
    update[data.call] = f[0];
    neo = data.merge(update, {
      merger: sim.concatArrayMerger
    });
    return emit.prox(neo);
  };
  verify.get.map = guard(function(data){
    var ref$;
    return (ref$ = data.type) === 'array' || ref$ === 'object';
  }, emit.get.chain).any(print.wrong_basetype_for_map);
  verify.get.on = guard(function(data){
    return registry.unit.on[data.type];
  }, emit.get.chain).any(print.wrong_basetype_for_on);
  verify.get.end = guard(function(data, key){
    return data[key];
  }, print.accepts_only_single_consumer_for_unit).when(function(data, key){
    return !(key === 'continue') && data.lockE;
  }, print.multi_error).any(emit.end);
  verify.get.consumption_error = guardjs().when(function(data, key){
    return registry.basetype[key];
  }, print.in_consumption_mode).when(function(data, key){
    return registry.router[key];
  }, print.in_consumption_mode).any(print.not_in_end);
  verify.get.chain = function(data, key){
    var F;
    F = (function(){
      switch (key) {
      case 'map':
        return verify.get.map;
      case 'on':
        return verify.get.on;
      case 'and':
      case 'or':
        return emit.get.chain;
      case 'continue':
      case 'error':
      case 'fix':
        return verify.get.end;
      default:
        return print.not_unit;
      }
    }());
    return F(data, key);
  };
  verify.get.init = guardjs().when(function(d, k){
    return registry.basetype[k];
  }, emit.get.basetype).when(function(d, k){
    return registry.helper[k];
  }, function(d, k){
    return registry.helper[k];
  }).when(function(d, k){
    return registry.router[k];
  }, print.unit_not_on_top).any(print.not_in_base_or_help);
  get = guardjs().when(function(data, key){
    return key === utilInspectCustom;
  }, print.pretty).any(function(data, key){
    var F;
    key = (function(){
      switch (key) {
      case 'err':
        return 'error';
      case 'con':
      case 'cont':
        return 'continue';
      default:
        return key;
      }
    }());
    F = (function(){
      switch (data.state) {
      case 'init':
        return verify.get.init;
      case 'chain':
        return verify.get.chain;
      case 'end':
        switch (key) {
        case 'continue':
        case 'error':
        case 'fix':
          return verify.get.end;
        default:
          return verify.get.consumption_error;
        }
      case 'fault':
        return print.fix_top_error.get;
      default:
        return print.unknown_ap_call;
      }
    }());
    return F(data, key);
  });
  verify.ap.on.entry = guard(verify.ap.on.types, emit.ap.chain).any(print.wrong_type_for_object_on);
  verify.ap.chain = guardjs().when(function(data, args){
    var Fns, i$, len$, F;
    Fns = R.flatten(args);
    for (i$ = 0, len$ = Fns.length; i$ < len$; ++i$) {
      F = Fns[i$];
      if (!(typeof F === 'function')) {
        return true;
      }
    }
    return false;
  }, print.call_has_to_be_function).any(emit.ap.chain);
  verify.ap.end = guardjs().when(function(data, args){
    return 1 < args.length;
  }, print.accepts_only_a_single_argument).any(emit.ap.end);
  emit.ap.custom = function(data, arg$){
    var f, custom;
    f = arg$[0];
    custom = function(v){
      return registry.sanatize(f, v);
    };
    return emit.prox(
    data.merge(
    {
      type: 'custom',
      validator: custom,
      state: 'chain'
    }));
  };
  verify.ap.custom = guardjs().when(function(data, args){
    return !(typeof args[0] === 'function');
  }, print.custom_only_function).when(function(data, args){
    return args.length > 1;
  }, print.single_init_function).any(emit.ap.custom);
  ap = guardjs().when(function(data, args){
    var ref$;
    return data.call === null && ((ref$ = data.state) === 'end' || ref$ === 'chain');
  }, emit.ap.resolve).any(function(data, args){
    var F;
    F = (function(){
      switch (data.state) {
      case 'chain':
        switch (data.call) {
        case 'on':
          return verify.ap.on.entry;
        default:
          return verify.ap.chain;
        }
      case 'end':
        return verify.ap.end;
      case 'init':
        return verify.ap.custom;
      case 'fault':
        return print.fix_top_error.ap;
      default:
        return print.unknown_ap_call;
      }
    }());
    return F(data, args);
  });
  handle = function(data){
    this.data = data;
    return this;
  };
  handle.prototype.get = function(__, key, ___){
    return get(this.data, key);
  };
  handle.prototype.apply = function(__, ___, args){
    return ap(this.data, args);
  };
  handle.of = function(data){
    return new handle(data);
  };
  start = function(){
    var defData, all, init, IS;
    defData = {
      all: [],
      validator: null,
      type: null,
      call: null,
      'continue': null,
      error: null,
      fix: null,
      lockE: false,
      state: 'init'
    };
    all = registry.cache.all;
    init = SI(defData);
    IS = new Proxy(noop, handle.of(init));
    registry.is = IS;
    registry.emit.ap.fault = emit.prox(
    init.merge(
    {
      state: 'fault'
    }));
    return IS;
  };
  IS = start();
  module.exports = IS;
}).call(this);
