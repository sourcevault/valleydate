// Generated by LiveScript 1.6.0
(function(){
  var reg, com, z, l, SI, R, noop, binapi, hop, data, V, map, E, veri, verify_f, be;
  reg = require("./registry");
  require("./print");
  com = reg.com;
  z = com.z, l = com.l, SI = com.SI, R = com.R, noop = com.noop;
  binapi = com.binapi, hop = com.hop;
  data = {};
  data.dirty = {
    all: [],
    type: null,
    'continue': null,
    error: null,
    def: null,
    fix: null,
    state: 'init'
  };
  data.def = SI(data.dirty);
  V = {};
  map = {};
  map.basetype = function(arg$){
    var prop, name;
    prop = arg$[0];
    name = (function(){
      switch (prop) {
      case 'obj':
      case 'object':
        return 'obj';
      case 'arr':
      case 'array':
        return 'arr';
      }
    }());
    if (name) {
      return ['struct', name];
    }
    name = (function(){
      switch (prop) {
      case 'str':
      case 'string':
        return 'str';
      case 'null':
        return 'null';
      case 'num':
      case 'number':
        return 'num';
      case 'undef':
        return 'undef';
      case 'fun':
      case 'function':
        return 'fun';
      case 'bool':
      case 'boolean':
        return 'bool';
      }
    }());
    if (name) {
      return ['atom', name];
    }
  };
  map.ending = function(arg$){
    var prop, unit;
    prop = arg$[0];
    unit = (function(){
      switch (prop) {
      case 'fix':
        return 'fix';
      case 'err':
      case 'erro':
      case 'error':
        return 'erro';
      case 'cont':
      case 'continue':
        return 'cont';
      }
    }());
    if (unit) {
      return ['ending', unit];
    }
  };
  map.router = function(arg$){
    var prop, unit;
    prop = arg$[0];
    unit = (function(){
      switch (prop) {
      case 'and':
        return 'and';
      case 'or':
        return 'or';
      case 'map':
        return 'map';
      case 'on':
        return 'on';
      }
    }());
    if (unit) {
      return ['router', unit];
    }
  };
  map.hepler = function(arg$){
    var prop;
    prop = arg$[0];
    prop = (function(){
      switch (prop) {
      case 'req':
      case 'required':
        return 'req';
      case 'int':
      case 'integer':
        return 'int';
      case 'reqf':
      case 'required_fuzzy':
        return 'reqf';
      }
    }());
    if (prop) {
      return ['helper', prop];
    }
  };
  E = {};
  E.V = {};
  E.F = {};
  E.H = {};
  E.H.type = hop.ma(map.basetype, map.router, map.hepler, map.ending).def(['fault']);
  veri = {};
  veri.on = hop.arwh(1, function(arg$){
    var user;
    user = arg$[0];
    switch (R.type(user)) {
    case 'Object':
      return [];
    default:

    }
  }, noop).u;
  verify_f = function(user){
    if (!(user.length === 1)) {
      return ['fault', 'arglen'];
    }
    switch (typeof user[0]) {
    case 'function':
      return ['ok', user];
    default:
      return ['fault', 'first'];
    }
  };
  E.F.one = function(arg$){
    var fname, ret, type;
    fname = arg$[0];
    ret = E.H.type(fname);
    type = ret[0];
    switch (type) {
    case 'router':
      return ['fault', ['one', 'is_router']];
    case 'ending':
      return ['fault', ['one', 'is_ending']];
    case 'fault':
      return ['fault', ['one', 'is_unknown']];
    default:
      return ['re', ret];
    }
  };
  E.F.two = function(arg$, user){
    var base, unit, ret, baseT, bName, unitT, uName;
    base = arg$[0], unit = arg$[1];
    ret = E.H.type(base);
    baseT = ret[0], bName = ret[1];
    switch (baseT) {
    case 'router':
    case 'ending':
      return ['fault', ['two.base', baseT]];
    case 'fault':
      return ['fault', ['two.base', 'is_unknown']];
    }
    ret = E.H.type(unit);
    unitT = ret[0], uName = ret[1];
    switch (unitT) {
    case 'fault':
      return ['fault', ['two.unit', 'unknown']];
    case 'atom':
    case 'struct':
    case 'hepler':
      return ['fault', ['two.unit', unitT]];
    }
    switch (uName) {
    case 'map':
    case 'on':
      switch (baseT) {
      case 'atom':
        return ['fault', ['two.map_on_atom']];
      }
    }
    return ret = (function(){
      switch (uName) {
      case 'on':
        return veri.on(user);
      }
    }());
  };
  E.F.path = function(arg$){
    var p, ar;
    p = arg$[0], ar = arg$[1];
    switch (p.length) {
    case 1:
      return E.F.one(p);
    case 2:
      return E.F.two(p, ar);
    default:
      return ['fault', 'path_too_long'];
    }
  };
  E.main = hop.wh(function(arg$){
    var p, ar, d;
    p = arg$[0], ar = arg$[1], d = arg$[2];
    return d.state === 'init';
  }, E.F.path);
  be = binapi(E.main, data.def);
  be.obj.on('foo', function(){}, 'bar', function(){});
  be.obj.on({
    foo: function(){},
    bar: function(){}
  });
  be.obj.on(['foo', 'bar'], function(){});
}).call(this);
