// Generated by LiveScript 1.6.0
(function(){
  var ref$, l, z, chalk, R, guard, guardjs, moduleName, prettyError, noops, registry, x$, c, repoUrl, print, help, pe, show_stack, close, gen_chain, top, internal;
  ref$ = require("./common"), l = ref$.l, z = ref$.z, chalk = ref$.chalk, R = ref$.R, guard = ref$.guard, guardjs = ref$.guardjs, moduleName = ref$.moduleName;
  ref$ = require("./common"), prettyError = ref$.prettyError, noops = ref$.noops;
  registry = require("./registry");
  x$ = c = {};
  x$.ok = chalk.green.bold;
  x$.er = chalk.hex("FF0000");
  x$.warn = chalk.hex("FFFFCD");
  x$.black = chalk.rgb(128, 128, 128).bold;
  repoUrl = "https://github.com/sourcevault/valleydate";
  print = {};
  help = c.black("[      docs] " + repoUrl);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.drop(4, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.packageName === "guard-js") {
      return true;
    }
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    if (traceLine.what === "Object.print.stack") {
      return true;
    }
    if (traceLine.what === "handle.fun.get.entry [as get]") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  show_stack = function(){
    var E;
    E = pe.render(new Error());
    l(E);
  };
  close = function(data){
    l(help);
    show_stack();
    return registry.emit.prox(
    data.merge(
    {
      state: 'fault',
      call: 'fault'
    }));
  };
  print.wrong_basetype_for_map = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.er((data.type + "." + key) + c.warn(" <<--\n")));
    l(c.warn("   map can only be used for basetype object and array.\n"));
    return close(data);
  };
  gen_chain = function(data){
    var str, ret, res$, i$, ref$, len$, I;
    str = data.type;
    if (data.all.length > 0) {
      res$ = [];
      for (i$ = 0, len$ = (ref$ = data.all).length; i$ < len$; ++i$) {
        I = ref$[i$];
        res$.push(I[0]);
      }
      ret = res$;
      str = "." + str + "." + ret.join("(~).") + "(~)";
    }
    return str;
  };
  print.call_has_to_be_function = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + data.call + "(~)") + c.warn(" <<--\n"));
    l(c.warn("   only functions can be passed into unit function.\n"));
    return close(data);
  };
  print.wrong_type_for_object_on = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + data.call + "(...)") + c.warn(" <<--\n"));
    l(c.warn("   wrong type/argument for " + data.type + ".on\n"));
    return close(data);
  };
  print.wrong_basetype_for_on = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.er((data.type + "." + key) + c.warn(" <<--\n")));
    l(c.warn("   on cannot be used for basetype " + data.type + ".\n"));
    return close(data);
  };
  print.fail = function(message){
    return function(){
      l(c.er("[TEST ERROR] originating from module"), c.warn("[" + repoUrl + "]"), c.er("\n\n\t - 'npm test' failed at TEST " + message + ". \n"));
      process.exitCode = 1;
    };
  };
  print.not_unit = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.warn("   " + c.er("." + key) + " is not a valid unit function for basetype " + data.type + ".\n"));
    return close(data);
  };
  print.single_init_function = function(data){
    l(c.er("[" + moduleName + "][error]"), c.er("<!custom validator creator!>\n"));
    l(c.warn("   only accepts a single initization function (argument).\n\n"), c.warn("  use .and .or to pass subsequent validator functions.\n"));
    return close(data);
  };
  print.custom_only_function = function(data){
    l(c.er("[" + moduleName + "][error]"), c.er("<!custom validator creator!>\n"));
    l(c.warn("   only function type accepted.\n"));
    return close(data);
  };
  print.accepts_only_single_consumer_for_unit = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.er("   ." + key), c.warn("defined once already.\n\n"), c.warn("  multiple consumption path can't co-exist.\n"));
    return close(data);
  };
  print.not_in_end = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.er("   ." + key), c.warn("is not a valid consumption unit.\n"));
    return close(data);
  };
  print.in_consumption_mode = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.warn("   chain can't be modified in consumption mode.\n"));
    return close(data);
  };
  print.def_and_error = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.warn("  both .error and .fix can't exist in the same validation chain\n\n"), c.warn(" .def (stands for default) is a substitute for error path.\n"));
    return close(data);
  };
  print.def_argument_is_function = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data) + "." + data.call) + c.er("(~)") + c.warn(" <<--\n"));
    l(c.warn("  argument for .def can't be a function, use .error for functions.\n"));
    return close(data);
  };
  print.fix_top_error = {};
  print.fix_top_error.ap = function(data, args){
    l(c.er("↑ ↑ .. [upstream fault in validator chain].. ↑ ↑\n"));
    if (data.call) {
      return registry.emit.prox(
      data.merge(
      {
        state: 'fault',
        call: null
      }));
    } else {
      return {
        'continue': false,
        error: true,
        value: null,
        message: "fault in validator chain"
      };
    }
  };
  print.fix_top_error.get = function(data, key){
    l(c.er("↑ ↑ .. [upstream fault in validator chain].. ↑ ↑\n"));
    return registry.emit.prox(
    data.merge(
    {
      state: 'fault',
      call: key
    }));
  };
  print.accepts_only_a_single_argument = function(data, args){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + data.call + "(~)") + c.warn(" <<--\n"));
    l(c.warn("    too many arguments for function"), c.er("." + data.call), c.warn("only single argument accepted.\n"));
    return close(data, args);
  };
  print.not_in_base_or_help = function(data, key){
    var ret, res$, i$, ref$, len$, I;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = data.all).length; i$ < len$; ++i$) {
      I = ref$[i$];
      res$.push(I[0]);
    }
    ret = res$;
    if (data.type) {
      ret.unshift(data.type);
    }
    if (data.call) {
      ret.unshift(data.call);
    }
    l(c.er("[" + moduleName + "][error]"), c.ok(ret.join(".")) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.warn("   " + c.er("." + key) + " is not part of module.\n"));
    return close(data);
  };
  print.not_an_object = function(data, prop){
    l(c.er(moduleName + "[error]"), c.ok(data.call) + c.er(("." + prop) + c.warn(" <<--\n")));
    l(c.ok(data.call) + c.warn(" is a function, not a object."));
    return close(data);
  };
  print.top_level_is_not_function = function(data, prop){
    l(c.er("[" + moduleName + "][error] validator chain is empty.\n"));
    l(c.warn("   top level object is not a function that can be called.\n"));
    return close(data);
  };
  print.unknown_ap_call = function(data, prop){
    l(c.er("[" + moduleName + "][error]\n"));
    l(c.warn("   Error not defined, please contact author or raise an issue.\n"));
    return close(data);
  };
  print.unit_not_on_top = function(data, prop){
    l(c.er("[" + moduleName + "][error]"), c.er(("." + prop) + c.warn(" <<--\n")));
    l(c.warn(" unit function " + c.ok("." + prop) + " cannot be called on top level object.\n"));
    l(c.warn(" only basetypes and helper are allowed.\n\n"));
    return close(data);
  };
  top = function(){
    var help, base, str;
    help = Object.keys(registry.helper);
    base = Object.keys(registry.basetype);
    str = [c.ok(moduleName), c.ok(" - assorted list of module routinues.\n"), c.ok("[  basetype] "), c.warn(base.join(c.ok("|"))), "\n", c.ok("[    helper] "), c.warn(help.join(c.ok("|")))];
    return str.join("");
  };
  internal = function(data){
    var chain, i$, ref$, len$, I, inn, str;
    if (data.type === null) {
      return "||";
    }
    chain = [];
    for (i$ = 0, len$ = (ref$ = data.all).length; i$ < len$; ++i$) {
      I = ref$[i$];
      chain.push(c.warn(I[0] + " (" + I[1].length + ")"));
    }
    inn = [];
    if (inn.length > 0) {
      inn = "(" + inn.join(",") + ") ";
    }
    str = ["| " + data.type + " " + inn + "| ", chain.join(c.ok(" > "))];
    return str.join("");
  };
  print.requiredError = function(loc){
    l(c.er("[" + moduleName + "][error]"), c.er("key in position " + loc + " is not string type.\n"));
    l(c.warn("keys passed to helper function " + c.ok('.required') + " has to be string or number.\n"));
    l(help);
    return show_stack();
  };
  print.fault = function(data, key){
    return c.er("<! fault !> " + internal(data));
  };
  print.pretty = function(data, key){
    switch (data.state) {
    case 'init':
      return top(data, key);
    case 'fault':
      return print.fault(data, key);
    default:
      return internal(data, key);
    }
  };
  module.exports = print;
}).call(this);
