// Generated by LiveScript 1.6.0
(function(){
  var reg, com, print, l, z, cc, R, j, prettyError, hop, flat, pkgname, x$, c, help, pe, show_stack, lit, show_chain, show_name, y$, on_dtype, sort, includes, same, myflat;
  reg = require("./registry");
  com = reg.com, print = reg.print;
  l = com.l, z = com.z, cc = com.cc, R = com.R, j = com.j, prettyError = com.prettyError, hop = com.hop, flat = com.flat;
  print = reg.print;
  pkgname = reg.pkgname;
  x$ = c = {};
  x$.ok1 = cc.greenBright;
  x$.ok2 = cc.xterm(8);
  x$.warn = cc.xterm(209);
  x$.er1 = cc.xterm(196);
  x$.er2 = cc.magentaBright;
  x$.er3 = cc.redBright;
  x$.grey = cc.xterm(8);
  help = c.grey("[  docs] " + reg.homepage);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.takeLast(5, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  show_stack = function(){
    var E;
    l(help);
    E = pe.render(new Error());
    l(E);
  };
  print.fail = function(filename){
    return function(message){
      l("[TEST ERROR] originating from module", "[" + pkgname + "]", "\n\n- 'npm test' failed at " + filename + ":");
      if (message) {
        l("\n    " + message + "\n");
      }
      process.exitCode = 1;
    };
  };
  lit = R.pipe(R.zipWith(function(x, f){
    switch (R.type(f)) {
    case 'Function':
      return f(x);
    default:
      return x;
    }
  }), R.join(""), l);
  print.required_input = function(){
    lit(["[" + pkgname + "]", "[typeError]"], [c.er1, c.e3]);
    lit(['\n', "  .required only accepts string and number.", '\n'], [0, c.e2, 0]);
    return show_stack();
  };
  print.input_fault = function(arg$){
    var method_name, data, fi;
    method_name = arg$[0], data = arg$[1];
    fi = this.input_fault;
    switch (method_name) {
    case 'on':
      return fi.on(data);
    case 'map':
      return fi.map(data);
    case 'custom':
      return fi.custom(data);
    case 'and':
    case 'or':
      return fi.andor(data);
    }
  };
  show_chain = function(arg$){
    var init, last;
    init = arg$[0], last = arg$[1];
    return lit(["  ", init.join("."), "." + last, "(xx)", " <-- error here"], [0, c.ok1, c.er2, c.er3, c.er2]);
  };
  show_name = function(name, type){
    type == null && (type = "[inputError] ");
    return lit(["[" + pkgname + "]", type, name], [c.er1, c.er3, c.warn]);
  };
  print.input_fault.andor = function(arg$){
    var type, info;
    type = arg$[0], info = arg$[1];
    show_name("." + info[1]);
    l("");
    show_chain(info);
    l("");
    switch (type) {
    case 'arg_count':
      l(c.ok2("  no value passed.", "\n\n", " minimum of 1 argument of function type is needed."));
      break;
    case 'not_function':
      l(c.er1("  one of the argument is not a function."));
    }
    l("");
    l(c.ok2(" - | type signature / information | - "));
    l("");
    l(c.ok1(" - :: fun|[fun,..],..,.."));
    return l("");
  };
  print.input_fault.custom = function(arg$){
    var patt, loc;
    patt = arg$[0], loc = arg$[1];
    show_name("custom validator");
    l("");
    switch (patt) {
    case 'arg_count':
      l(c.ok2("  no value passed.", "\n\n", " minimum of 1 argument of function type is needed."));
      break;
    case 'not_function':
      l(c.er1("  first argument has to be a function."));
    }
    return l("");
  };
  print.input_fault.map = function(arg$){
    var patt, loc;
    patt = arg$[0], loc = arg$[1];
    show_name(".map");
    l("");
    show_chain(loc);
    l("");
    switch (patt) {
    case 'arg_count':
      l(c.ok2("  only accepts 1 argument required of function type."));
      break;
    case 'not_function':
      l(c.ok2("  first argument has to be a function."));
    }
    return l("");
  };
  y$ = on_dtype = {};
  y$.string = "string|number , function";
  y$.object = "object{*:function} ";
  y$.array = "[string|number....] , function";
  print.input_fault.on = function(arg$){
    var patt, loc, eType, lines, key, val, dtype;
    patt = arg$[0], loc = arg$[1];
    eType = (function(){
      switch (patt) {
      case 'typeError':
        return 'typeError';
      default:
        return 'inputError';
      }
    }());
    show_name(".on", "[" + eType + "] ");
    l("");
    show_chain(loc);
    l("");
    switch (patt) {
    case 'typeError':
    case 'arg_count':
      switch (patt) {
      case 'typeError':
        l(c.er1("  unable to pattern match on user input."));
        break;
      case 'arg_count':
        l(c.er1("  minimum of 2 arguments required."));
      }
      l("");
      lit([" - | types that may match ", ".on", " | -"], [c.ok2, c.ok1, c.white]);
      l("");
      lines = (function(){
        var ref$, results$ = [];
        for (key in ref$ = on_dtype) {
          val = ref$[key];
          results$.push(" - :: " + c.ok1(val));
        }
        return results$;
      }()).join("\n\n");
      l(lines);
      break;
    default:
      dtype = on_dtype[patt];
      lit([" .on", " :: ", dtype, " <-- what may match"], [c.warn, c.white, c.ok1, c.grey]);
    }
    return l("");
  };
  print.route = function(data){
    var ECLASS, info;
    ECLASS = data[0], info = data[1];
    switch (ECLASS) {
    case 'required_input':
      print.required_input();
      break;
    case 'input.fault':
      print.input_fault(info);
    }
    return show_stack();
  };
  print.log = function(){
    var all, prop, res$, i$, len$, name, str, I;
    all = Object.entries(this);
    res$ = [];
    for (i$ = 0, len$ = all.length; i$ < len$; ++i$) {
      name = all[i$][0];
      res$.push(name);
    }
    prop = res$;
    str = c.ok1("{.*}");
    str += c.ok1(" ");
    for (i$ = 0, len$ = prop.length; i$ < len$; ++i$) {
      I = prop[i$];
      str += c.ok2(I + " ");
    }
    return str;
  };
  sort = R.sort(function(a, b){
    return b.length - a.length;
  });
  includes = R.flip(R.includes);
  same = includes(['and', 'or', 'cont', 'jam', 'fix', 'err', 'map', 'on']);
  myflat = hop.ma(function(ob){
    switch (R.type(ob)) {
    case 'Function':
    case 'Object':
      return false;
    default:
      return {};
    }
  }).def(function(ob, fin){
    var keys, i$, len$, I, prop;
    fin == null && (fin = {});
    keys = Object.keys(ob);
    for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
      I = keys[i$];
      if (!same(I)) {
        prop = myflat(ob[I]);
        fin[I] = prop;
      }
    }
    return fin;
  });
  print.inner = function(){
    var props, res$, I, str;
    res$ = [];
    for (I in flat(myflat(this))) {
      res$.push(I);
    }
    props = res$;
    str = c.ok1("{.*}\n");
    str += c.grey(
    R.join("\n")(
    sort(
    props)));
    return str;
  };
  module.exports = print;
}).call(this);
