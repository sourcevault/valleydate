// Generated by LiveScript 1.6.0
(function(){
  var ref$, l, chalk, R, guard, moduleName, prettyError, noops, registry, x$, c, repoUrl, print, help, pe, show_stack, gen_chain, top, internal;
  ref$ = require("./common"), l = ref$.l, chalk = ref$.chalk, R = ref$.R, guard = ref$.guard, moduleName = ref$.moduleName;
  ref$ = require("./common"), prettyError = ref$.prettyError, noops = ref$.noops;
  registry = require("./registry");
  x$ = c = {};
  x$.ok = chalk.green.bold;
  x$.er = chalk.hex("FF0000");
  x$.warn = chalk.hex("FFFFCD");
  x$.black = chalk.rgb(128, 128, 128).bold;
  repoUrl = "https://github.com/sourcevault/valleydate";
  print = {};
  help = c.black("[      docs] " + repoUrl);
  pe = new prettyError();
  pe.skipNodeFiles();
  pe.filterParsedError(function(Error){
    Error._trace = R.drop(4, Error._trace);
    return Error;
  });
  pe.skip(function(traceLine, lineNumber){
    if (traceLine.packageName === "guard-js") {
      return true;
    }
    if (traceLine.dir === "internal/modules/cjs") {
      return true;
    }
    if (traceLine.what === "Object.print.stack") {
      return true;
    }
    if (traceLine.what === "handle.fun.get.entry [as get]") {
      return true;
    }
    return false;
  });
  pe.appendStyle({
    "pretty-error > header > title > kind": {
      display: "none"
    },
    "pretty-error > header > colon": {
      display: "none"
    },
    "pretty-error > header > message": {
      display: "none"
    }
  });
  show_stack = function(){
    var E;
    E = pe.render(new Error());
    l(E);
  };
  print.wrong_basetype_for_map = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.er((data.type + "." + key) + c.warn(" <<--\n")));
    l(c.warn("   map can only be used for basetype object and array.\n"));
    l(help);
    show_stack();
  };
  gen_chain = function(data){
    var str, ret, res$, i$, ref$, len$, I;
    str = "";
    if (data.type) {
      str = data.type + "." + str;
    }
    if (data.all.length > 0) {
      res$ = [];
      for (i$ = 0, len$ = (ref$ = data.all).length; i$ < len$; ++i$) {
        I = ref$[i$];
        res$.push(I[0]);
      }
      ret = res$;
      str = str + ret.join("(~~).") + "(~~)";
      if (data.call) {
        str = str + ".";
      }
    }
    if (data.call) {
      str = str + data.call;
    }
    return str;
  };
  print.call_has_to_be_function = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("(~~)") + c.warn(" <<--\n"));
    l(c.warn("   only functions can be passed into unit function.\n"));
    l(help);
    show_stack();
  };
  print.wrong_type_for_object_on = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("(...)") + c.warn(" <<--\n"));
    l(c.warn("   wrong type/argument for " + data.type + ".on\n"));
    l(help);
    show_stack();
  };
  print.wrong_basetype_for_on = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.er((data.type + "." + key) + c.warn(" <<--\n")));
    l(c.warn("   on cannot be used for basetype " + data.type + ".\n"));
    l(help);
    show_stack();
  };
  print.fail = function(num){
    l(c.er("[TEST ERROR] originating from module"), c.warn("[" + repoUrl + "]"), c.er("\n\n\t - 'npm test' failed at TEST " + num + ". \n"));
    process.exitCode = 1;
  };
  print.not_unit = function(data, key){
    l(c.er("[" + moduleName + "][error]"), c.ok(gen_chain(data)) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.warn("   " + c.er("." + key) + " is not a valid unit function for basetype " + data.type + ".\n"));
    l(help);
    return show_stack();
  };
  print.not_in_base_or_help = function(data, key){
    var ret, res$, i$, ref$, len$, I;
    res$ = [];
    for (i$ = 0, len$ = (ref$ = data.all).length; i$ < len$; ++i$) {
      I = ref$[i$];
      res$.push(I[0]);
    }
    ret = res$;
    if (data.type) {
      ret.unshift(data.type);
    }
    if (data.call) {
      ret.unshift(data.call);
    }
    l(c.er("[" + moduleName + "][error]"), c.ok(ret.join(".")) + c.er("." + key) + c.warn(" <<--\n"));
    l(c.warn("   " + c.er("." + key) + " is not part of module.\n"));
    l(help);
    show_stack();
  };
  print.not_an_object = function(data, prop){
    l(c.er(moduleName + "[error]"), c.ok(data.call) + c.er(("." + prop) + c.warn(" <<--\n")));
    l(c.ok(data.call) + c.warn(" is a function, not a object."));
    l(help);
  };
  print.top_level_is_not_function = function(data, prop){
    l(c.er("[" + moduleName + "][error] validator chain is empty.\n"));
    l(c.warn("   top level object is not a function that can be called.\n"));
    l(help);
    show_stack();
  };
  print.unknown_ap_call = function(data, prop){
    l(c.er("[" + moduleName + "][error]\n"));
    l(c.warn("   Error not defined, please contact author or raise an issue.\n"));
    l(help);
    show_stack();
  };
  print.unit_not_on_top = function(data, prop){
    l(c.er("[" + moduleName + "][error]"), c.er(("." + prop) + c.warn(" <<--\n")));
    l(c.warn(" unit function " + c.ok("." + prop) + " cannot be called on top level object.\n"));
    l(c.warn(" only basetypes and helper are allowed.\n\n"));
    l(help);
    show_stack();
  };
  top = function(){
    var help, base, str;
    help = Object.keys(registry.helper);
    base = Object.keys(registry.basetype);
    str = [c.ok(moduleName), c.ok(" - assorted list of module routinues.\n"), c.ok("[  basetype] "), c.warn(base.join(c.ok("|"))), "\n", c.ok("[    helper] "), c.warn(help.join(c.ok("|")))];
    return str.join("");
  };
  internal = function(data){
    var chain, i$, ref$, len$, I, inn, str;
    chain = [];
    for (i$ = 0, len$ = (ref$ = data.all).length; i$ < len$; ++i$) {
      I = ref$[i$];
      chain.push(c.warn(I[0] + " (" + I[1].length + ")"));
    }
    inn = [];
    if (data.call) {
      inn.push("call:" + data.call);
    }
    if (data['continue']) {
      inn.push("continue");
    }
    if (data.error) {
      inn.push("error");
    }
    if (inn.length > 0) {
      inn = "(" + inn.join(",") + ") ";
    }
    str = [c.ok("| " + data.type + " " + inn + "| "), chain.join(c.ok(" > "))];
    return str.join("");
  };
  print.requiredError = function(loc){
    l(c.er("[" + moduleName + "][error]"), c.er("key in position " + loc + " is not string type.\n"));
    l(c.warn("keys passed to helper function " + c.ok('.required') + " has to be string or number.\n"));
    l(help);
    return show_stack();
  };
  print.pretty = guard(function(data, key){
    return !data.type;
  }, top).any(internal);
  module.exports = print;
}).call(this);
