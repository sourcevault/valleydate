// Generated by LiveScript 1.6.0
(function(){
  var ref$, z, j, l, SI, R, guard, guardjs, noop, moduleName, unfinished, sim, utilInspectCustom, registry, booly, local, checkF, createError, x$, onn, create_atomic, i$, len$, val, key;
  ref$ = require("./common"), z = ref$.z, j = ref$.j, l = ref$.l, SI = ref$.SI, R = ref$.R, guard = ref$.guard, guardjs = ref$.guardjs, noop = ref$.noop, moduleName = ref$.moduleName;
  ref$ = require("./common"), unfinished = ref$.unfinished, sim = ref$.sim, utilInspectCustom = ref$.utilInspectCustom;
  registry = require("./registry");
  booly = new Set(["boolean", "null", "undefined", "number"]);
  local = {};
  local.sanatize = function(f, val, path){
    var ret, cont, unknown, out;
    ret = (function(){
      switch (typeof f) {
      case "function":
        return f(val, path);
      default:
        return f;
      }
    }());
    if (booly.has(typeof ret)) {
      if (ret) {
        return {
          'continue': true,
          error: false,
          value: val
        };
      } else {
        return {
          'continue': false,
          error: true,
          value: val,
          message: []
        };
      }
    } else if (Array.isArray(ret)) {
      cont = ret[0], unknown = ret[1];
      if (cont) {
        return {
          'continue': true,
          error: false,
          value: val
        };
      } else {
        out = {
          'continue': false,
          error: true,
          value: val
        };
        switch (typeof unknown) {
        case 'string':
          out.message = [unknown];
          break;
        default:
          out.message = ["[" + moduleName + "][error][user-supplied-validator] message has to be string."];
        }
        return out;
      }
    } else {
      out = {
        'continue': false,
        error: true,
        value: val
      };
      out.message = ["[" + moduleName + "][error][user-supplied-validator] unknown return type."];
      return out;
    }
  };
  checkF = function(ret, xf){
    switch (typeof xf) {
    case 'function':
      return xf(ret);
    default:
      return xf;
    }
  };
  registry.sideEffects = function(data, ret){
    var out, val;
    if (ret['continue']) {
      if (data['continue']) {
        ret.value = checkF(ret.value, data['continue']);
        return ret;
      }
    } else if (data.error) {
      out = data.error(ret);
    } else if (data.fix) {
      val = checkF(ret.value, data.fix);
      return {
        'continue': true,
        error: false,
        value: val
      };
    } else if (data.dispatch) {
      ret.dispatch = data.dispatch;
      return ret;
    }
    return ret;
  };
  createError = function(localRet, topValue, loc){
    var out, ref$;
    out = {
      'continue': false,
      error: true,
      value: topValue
    };
    if (loc) {
      out.path = [loc];
    } else {
      out.path = [];
    }
    if (localRet.path) {
      (ref$ = out.path).push.apply(ref$, localRet.path);
    }
    if (localRet.message) {
      out.message = localRet.message;
    } else {
      out.message = [];
    }
    return out;
  };
  registry.router = {
    and: function(data, funs){
      return function(val){
        return registry.unit.and(data, funs, val);
      };
    },
    or: function(data, funs){
      return function(val){
        return registry.unit.or(data, funs, val);
      };
    },
    map: function(data, arg$){
      var f;
      f = arg$[0];
      return function(val){
        return registry.unit.map[data.type](data, f, val);
      };
    },
    on: function(data, config){
      return function(val){
        return onn.entry(data, config, val);
      };
    }
  };
  registry.unit.and = function(data, funs, value){
    var topRet, i$, len$, f, localRet;
    topRet = data.validator(value);
    if (topRet['continue']) {
      value = topRet.value;
      for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
        f = funs[i$];
        localRet = registry.sanatize(f, value);
        if (localRet.error) {
          return localRet;
        } else {
          value = localRet.value;
        }
      }
      return {
        'continue': true,
        error: false,
        value: value
      };
    }
    return topRet;
  };
  registry.unit.or = function(data, funs, value){
    var topRet, i$, len$, f, localRet;
    topRet = data.validator(value);
    if (topRet['continue']) {
      return topRet;
    }
    for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
      f = funs[i$];
      localRet = registry.sanatize(f, value);
      if (localRet['continue']) {
        return localRet;
      }
      topRet.message = [":or", topRet.message, localRet.message];
      if (localRet.dispatch) {
        topRet.dispatch = localRet.dispatch;
        return topRet;
      }
    }
    return topRet;
  };
  registry.unit.map.array = function(data, f, value){
    var topRet, val, i$, len$, n, I, localRet;
    topRet = data.validator(value);
    if (topRet['continue']) {
      val = topRet.value;
      for (i$ = 0, len$ = val.length; i$ < len$; ++i$) {
        n = i$;
        I = val[i$];
        localRet = register.sanatize(f, I, n);
        if (localRet.error) {
          return createError(localRet, topRet.value, n);
        }
      }
    }
    return topRet;
  };
  x$ = onn = {};
  x$.entry = null;
  x$.user_object = null;
  x$.main = null;
  onn.main = function(pos, f, ob){
    var localRet;
    localRet = registry.sanatize(f, ob[pos]);
    if (localRet.error) {
      return createError(localRet, ob, pos);
    }
    ob[pos] = localRet.value;
    return localRet;
  };
  onn.user_object = function(data, arg$, UFO){
    var funs, topRet, loc, f, localRet;
    funs = arg$[0];
    topRet = data.validator(UFO);
    if (topRet['continue']) {
      for (loc in funs) {
        f = funs[loc];
        localRet = onn.main(loc, f, topRet.value);
        if (localRet.error) {
          localRet.message = [":on", loc, localRet.message];
          return localRet;
        }
      }
    }
    return topRet;
  };
  onn.entry = guardjs().when(function(data, args, UFO){
    return typeof args[0] === 'object';
  }, onn.user_object).when(function(data, args, UFO){
    return args.length === 2;
  }, function(data, args, UFO){
    var ref$;
    return onn.user_object(data, [(ref$ = {}, ref$[args[0] + ""] = args[1], ref$)], UFO);
  });
  registry.unit.map.object = function(data, f, UFO){
    var topRet, key, ref$, value, localRet;
    topRet = data.validator(UFO);
    if (topRet['continue']) {
      for (key in ref$ = topRet.value) {
        value = ref$[key];
        localRet = registry.sanatize(f, value, key);
        if (localRet.error) {
          return createError(localRet, topRet.value, key);
        }
      }
    }
    return topRet;
  };
  registry.sanatize = function(f, val, path){
    if (registry.cache.all.has(f)) {
      return f(val, path);
    } else {
      return local.sanatize(f, val, path);
    }
  };
  create_atomic = function(name){
    return function(UFO){
      var Type;
      Type = typeof UFO;
      if (Type === name) {
        return {
          error: false,
          'continue': true,
          value: UFO
        };
      } else {
        return {
          error: true,
          'continue': false,
          message: ["not a " + name],
          value: UFO
        };
      }
    };
  };
  R.forEach(function(name){
    return registry.basetype[name] = create_atomic(name);
  }, ["function", "boolean", "number", "string"]);
  registry.basetype['null'] = function(UFO){
    if (UFO === null) {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: ["not a null"],
        value: UFO
      };
    }
  };
  registry.basetype.undef = function(UFO){
    var Type;
    Type = typeof UFO;
    if (Type === 'undefined') {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: ["not undefined"],
        value: UFO
      };
    }
  };
  registry.basetype.array = function(UFO){
    if (Array.isArray(UFO)) {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: ["not a array"],
        value: UFO
      };
    }
  };
  registry.basetype.object = function(UFO){
    var basetype;
    basetype = typeof UFO;
    if (basetype === "object" && !Array.isArray(UFO)) {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: ["not an object"],
        value: UFO
      };
    }
  };
  for (i$ = 0, len$ = (ref$ = registry.basetype).length; i$ < len$; ++i$) {
    val = i$;
    key = ref$[i$];
    registry.cache.all.add(val);
  }
}).call(this);
