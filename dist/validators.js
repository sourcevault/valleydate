// Generated by LiveScript 1.6.0
(function(){
  var ref$, l, SI, R, guard, noops, moduleName, unfinished, sim, utilInspectCustom, registry, booly, local, createError, x$, obj, create_atomic, i$, len$, val, key;
  ref$ = require("./common"), l = ref$.l, SI = ref$.SI, R = ref$.R, guard = ref$.guard, noops = ref$.noops, moduleName = ref$.moduleName;
  ref$ = require("./common"), unfinished = ref$.unfinished, sim = ref$.sim, utilInspectCustom = ref$.utilInspectCustom;
  registry = require("./registry");
  booly = new Set(["boolean", "null", "undefined", "number"]);
  local = {};
  local.sanatize = function(f, val, path){
    var ret, cont, message, out;
    ret = f(val, path);
    if (booly.has(typeof ret)) {
      if (ret) {
        return {
          'continue': true,
          error: false,
          value: val
        };
      } else {
        return {
          coninue: false,
          error: true,
          value: val
        };
      }
    } else if (Array.isArray(ret)) {
      cont = ret[0], message = ret[1];
      if (cont) {
        return {
          'continue': true,
          error: false,
          value: val
        };
      } else {
        return {
          'continue': false,
          error: true,
          value: val,
          message: message
        };
      }
    } else {
      out = {
        'continue': false,
        error: true,
        value: val
      };
      out.message = moduleName + "[error] unknown return type from user supplied validator.";
      return out;
    }
  };
  registry.sideEffects = function(data, ret){
    var i$, ref$, len$, f, results$ = [];
    if (ret['continue'] && data['continue']) {
      for (i$ = 0, len$ = (ref$ = data['continue']).length; i$ < len$; ++i$) {
        f = ref$[i$];
        f(ret.value);
      }
    } else if (data.error) {
      for (i$ = 0, len$ = (ref$ = data.error).length; i$ < len$; ++i$) {
        f = ref$[i$];
        f(ret.value);
      }
    }
    if (data.tap) {
      for (i$ = 0, len$ = (ref$ = data.tap).length; i$ < len$; ++i$) {
        f = ref$[i$];
        results$.push(f(ret.value));
      }
      return results$;
    }
  };
  createError = function(localRet, topValue, loc){
    var out;
    out = {
      'continue': false,
      error: true,
      value: topValue
    };
    if (loc) {
      out.path = [loc];
    } else {
      out.path = [];
    }
    if (localRet.path) {
      out.path = out.path.concat(localRet.path);
    }
    if (localRet.message) {
      out.message = localRet.message;
    } else {
      out.message = "";
    }
    return out;
  };
  registry.router = {
    and: function(data, funs){
      return function(val){
        return registry.unit.and(data, funs, val);
      };
    },
    or: function(data, funs){
      return function(val){
        return registry.unit.or(data, funs, val);
      };
    },
    edit: function(data, arg$){
      var f;
      f = arg$[0];
      return function(val){
        return registry.unit.edit(data, f, val);
      };
    },
    map: function(data, arg$){
      var f;
      f = arg$[0];
      return function(val){
        return registry.unit.map[data.type](data, f, val);
      };
    },
    on: function(data, config){
      return function(val){
        return registry.unit.on[data.type](data, config, val);
      };
    }
  };
  registry.unit.and = function(data, funs, value){
    var topRet, i$, len$, f, localRet;
    topRet = data.validator(value);
    if (topRet['continue']) {
      value = topRet.value;
      for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
        f = funs[i$];
        localRet = registry.sanatize(f, value);
        if (localRet.error) {
          return localRet;
        } else {
          value = localRet.value;
        }
      }
      return {
        'continue': true,
        error: false,
        value: value
      };
    }
    return topRet;
  };
  registry.unit.or = function(data, funs, value){
    var topRet, messages, i$, len$, f, localRet;
    topRet = data.validator(value);
    if (topRet['continue']) {
      return {
        'continue': true,
        error: false,
        value: topRet.value
      };
    }
    messages = [topRet.message];
    for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
      f = funs[i$];
      localRet = registry.sanatize(f, value);
      if (localRet['continue']) {
        return {
          'continue': true,
          error: false,
          value: localRet.value
        };
      }
      messages.push(localRet.message);
    }
    return {
      'continue': false,
      error: true,
      value: value,
      message: messages.join(" or ")
    };
  };
  registry.unit.map.array = function(data, f, value){
    var topRet, val, i$, len$, n, I, localRet;
    topRet = data.validator(value);
    if (topRet['continue']) {
      val = topRet.value;
      for (i$ = 0, len$ = val.length; i$ < len$; ++i$) {
        n = i$;
        I = val[i$];
        localRet = register.sanatize(f, I, n);
        if (localRet.error) {
          return createError(localRet, topRet.value, n);
        }
      }
    }
    return topRet;
  };
  x$ = obj = {};
  x$.entry = null;
  x$.single = null;
  x$.obj = null;
  obj.single = function(data, args, UFO){
    var topRet, pos, f, onValue, localRet;
    topRet = data.validator(UFO);
    if (topRet['continue']) {
      pos = args[0], f = args[1];
      onValue = topRet.value[pos];
      if (!(onValue === undefined)) {
        localRet = registry.sanatize(f, onValue);
        if (localRet.error) {
          return createError(localRet, topRet.value, pos);
        } else {
          topRet.value[pos] = localRet.value;
          return {
            'continue': true,
            error: false,
            value: topRet.value
          };
        }
      }
    }
    return topRet;
  };
  obj.obj = function(data, arg$, UFO){
    var funs, loc, f, localRet;
    funs = arg$[0];
    for (loc in funs) {
      f = funs[loc];
      localRet = obj.single(data, [loc, f], UFO);
      if (localRet.error) {
        return localRet;
      }
    }
    return {
      'continue': true,
      error: false,
      value: UFO
    };
  };
  obj.entry = guard(function(data, args, UFO){
    return typeof args[0] === 'object';
  }, obj.obj).when(function(data, args, UFO){
    return args.length === 2;
  }, obj.single);
  registry.unit.on.object = obj.entry;
  registry.unit.on.array = obj.entry;
  registry.unit.map.object = function(data, f, UFO){
    var topRet, key, ref$, value, localRet;
    topRet = data.validator(UFO);
    if (topRet['continue']) {
      for (key in ref$ = topRet.value) {
        value = ref$[key];
        localRet = registry.sanatize(f, value, key);
        if (localRet.error) {
          return createError(localRet, topRet.value, key);
        }
      }
    }
    return topRet;
  };
  registry.unit.edit = function(data, f, UFO){
    var topRet;
    topRet = data.validator(UFO);
    if (topRet['continue']) {
      return {
        'continue': true,
        error: false,
        value: f(topRet.value)
      };
    }
    return topRet;
  };
  registry.sanatize = function(f, val, path){
    if (registry.cache.all.has(f)) {
      return f(val, path);
    } else {
      return local.sanatize(f, val, path);
    }
  };
  create_atomic = function(name){
    return function(UFO){
      var Type;
      Type = typeof UFO;
      if (Type === name) {
        return {
          error: false,
          'continue': true,
          value: UFO
        };
      } else {
        return {
          error: true,
          'continue': false,
          message: "not a " + name
        };
      }
    };
  };
  R.forEach(function(name){
    return registry.basetype[name] = create_atomic(name);
  }, ["function", "boolean", "number", "string", "undefined"]);
  registry.basetype['null'] = function(UFO){
    if (UFO === null) {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: "not a null"
      };
    }
  };
  registry.basetype.array = function(UFO){
    if (Array.isArray(UFO)) {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: "not a array"
      };
    }
  };
  registry.basetype.object = function(UFO){
    var basetype;
    basetype = typeof UFO;
    if (basetype === "object" && !Array.isArray(UFO)) {
      return {
        error: false,
        'continue': true,
        value: UFO
      };
    } else {
      return {
        error: true,
        'continue': false,
        message: "not an object"
      };
    }
  };
  for (i$ = 0, len$ = (ref$ = registry.basetype).length; i$ < len$; ++i$) {
    val = i$;
    key = ref$[i$];
    registry.cache.all.add(val);
  }
}).call(this);
